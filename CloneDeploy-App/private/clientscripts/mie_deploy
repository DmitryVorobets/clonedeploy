#!/bin/bash

. /usr/local/bin/mie_global_functions


function process_hard_drives()
{
  
  create_all_partition_layouts
  
  #Do it all again, There may be new hard drives listed now that all partitions have been created because of Core Storage
  local drive_name
  local lbs
  local drive_size_block
  
  get_hard_drives "deploy"
  
  imaged_schema_drives=""
  current_hd_number=-1
  for hard_drive in $hard_drives; do
    echo
    
    current_hd_number=$(( $current_hd_number + 1 ))
    log " ** Processing $hard_drive ** " "display"
    
    drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    logical_block_size="$(diskutil info $hard_drive | grep "Device Block Size:" | cut -d : -f2 | sed 's/Bytes//g' | sed -e 's/^[ \t]*//')"
    hard_drive_size_bytes=$(diskutil info $hard_drive | grep "$hd_size_param" | cut -d "(" -f2 | cut -d " " -f1 )
    
    log "Get hd_schema:  profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$imaged_schema_drives&clientLbs=0"
    hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$(remove_whitespace $imaged_schema_drives)&clientLbs=0" "${web}CheckHdRequirements" $curlEnd)
    log "$hd_schema"
    
    image_hd_to_use=$(parse_json "$hd_schema" .SchemaHdNumber)
    image_path=/storage/images/$image_name/hd$image_hd_to_use
    
    process_partitions
    
    imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "
    
    #Set recovery volume boot type
    osx_recovery_volume="Recovery HD"
    osx_recovery_partition=${drive_name}$(diskutil list | grep $drive_name | grep -vw $drive_name | grep "$osx_recovery_volume" | awk -F"$drive_name"  '{print $2}')
    recover_info=$(diskutil info "$osx_recovery_partition")
    if [ "$?" = "0" ]; then
      log "Setting $osx_recovery_partition to Apple_Boot"
      diskutil umount "$osx_recovery_partition"
      asr adjust -target "/dev/$osx_recovery_partition" -settype Apple_Boot
    fi
    
    if [ "$(parse_json "$hd_schema" .Guid)" = "simple" ]; then
      break
    fi
    
    
  done
}

function create_all_partition_layouts
{
  log " ** Creating Partition Layouts ** " "display"
  
  #remove all existing logical volumes before beginning, as changes cannot be made to physical disks while they are present
  #Todo:  This will remove all logical volumes even if you aren't deploying an image to that drive
  
  
  #The partition layout for all hard drives must be created before any imaging can begin
  #In the case that Core storage spans across multiple disks
  get_hard_drives "deploy"
  imaged_schema_drives=""
  current_hd_number=-1
  for hard_drive in $hard_drives; do
    echo
    
    current_hd_number=$(( $current_hd_number + 1 ))
    
    if [[ "$partition_method" == *"standard"* ]]; then
      if [ "$current_hd_number" -gt "0" ]; then
        continue #this only needs run once, it will be called for each hard drive but doesn't need to be for standard layouts
      fi
    fi
    
    log " ** Processing $hard_drive ** " "display"
    
    
    drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    logical_block_size="$(diskutil info $hard_drive | grep "Device Block Size:" | cut -d : -f2 | sed 's/Bytes//g' | sed -e 's/^[ \t]*//')"
    hard_drive_size_bytes=$(diskutil info $hard_drive | grep "$hd_size_param" | cut -d "(" -f2 | cut -d " " -f1 )
    
    log "Get hd_schema:  profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$imaged_schema_drives&clientLbs=0"
    hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$(remove_whitespace $imaged_schema_drives)&clientLbs=0" "${web}CheckHdRequirements" $curlEnd)
    log "$hd_schema"
    
    image_hd_to_use=$(parse_json "$hd_schema" .SchemaHdNumber)
    image_path=/storage/images/$image_name/hd$image_hd_to_use
    
    create_partition_layout
    log " ** New Partition Table Is ** "
    diskutil list $hard_drive >> $CLIENT_LOG 2>&1
    
    imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "
  done
  
  #Now that all partitions have been created check for and create corestorage
  
  create_dynamic_cs_layouts
  
}


function create_partition_layout()
{
  local layout_created_successfully
  local layout_failed_counter
  local gpt_partition_count
  local mbr_partition_count
  local preexisting_volume_groups
  local preexisting_physical_volumes
  local new_volume_groups
  local new_logical_volumes
  local volume_group_uuid
  local logical_volume_uuid
  
  if [ "$(parse_json "$hd_schema" .IsValid)" = "true" ] || [ "$(parse_json "$hd_schema" .IsValid)" = "original" ]; then
    log " ...... HD Meets The Minimum Sized Required"
    elif [ "$(parse_json "$hd_schema" .IsValid)" = "false" ]; then
    log " ...... $(parse_json "$hd_schema" .Message)" "display"
    sleep 10
    continue
  else
    error "Unknown Error Occurred While Determining Minimum HD Size Required.  Check The Exception Log"
  fi
  
  get_partitions_according_to_mbr_gpt
  partition_counter=0
  for partition in $mbr_gpt_partitions; do
    partition_counter=$(( $partition_counter + 1 ))
    partition_number=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
    partition_prefix=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g'`
    break
  done
  
  if [ "$partition_method" = "standard_auto" ] || [ "$partition_method" = "standard" ]; then #standard is legacy, assume standard is now standard_auto
    local array_index=-1
    while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
      array_index=$(( $array_index + 1))
      clear_and_move_down
      current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
      log "$current_partition"
      
      if [ "$(parse_json "$current_partition" .Guid)" = "os" ]; then
        os_volume_found="true"
        source_filesystem="$(parse_json "$current_partition" .FileSystem)"
        log "source_filesystem: $source_filesystem"
        if echo "$source_filesystem" | grep -i "apfs" > /dev/null; then
          if diskutil list | grep -i "hfs" | grep "$osx_target_volume" > /dev/null; then
            log "WARNING:  You are attempting to deploy an APFS image to a system that is currently using HFS.  If this system has not yet had a firmware update, it may fail to boot." "display"
            sleep 15
          fi
          if diskutil list | grep -i "apfs" | grep "$osx_target_volume" > /dev/null; then
            log "There is already an apfs filesystem for $osx_target_volume No partition changes will be made"
            if [ "$erase_partitions" = "true" ]; then
              log "New partition layout has been enforced"
              create_standard_apfs
            fi
            partition_method="standard_apfs"
          else
            create_standard_apfs
            partition_method="standard_apfs"
          fi
          
        else #assume hfs
          #check if there is a current hfsp target volume
          if diskutil list | grep -i "hfs" | grep "$osx_target_volume" > /dev/null; then
            log "There is already an hfs filesystem for $osx_target_volume No partition changes will be made"
            if [ "$hard_drive_count" -gt 1 ]; then
              if [ "$erase_partitions" = "true" ]; then
                log "New partition layout has been enforced"
                create_standard_cs
              fi
              partition_method="standard_cs"
            else
              if [ "$erase_partitions" = "true" ]; then
                log "New partition layout has been enforced"
                create_standard_hfsp
              fi
              partition_method="standard_hfsp"
            fi
          else
            if [ "$hard_drive_count" -gt 1 ]; then
              create_standard_cs
              partition_method="standard_cs"
            else
              create_standard_hfsp
              partition_method="standard_hfsp"
            fi
          fi
          
        fi
        break
      fi
    done
    
    if [ "$os_volume_found" != "true" ]; then
      error "Could Not Find OS Volume On Source Image"
    fi
    
    elif [ "$partition_method" = "standard_hfsp" ]; then
    
    create_standard_hfsp
    
    elif [ "$partition_method" = "standard_apfs" ]; then
    
    create_standard_apfs
    
    elif [ "$partition_method" = "standard_cs" ]; then
    
    create_standard_cs
    
    
    elif [ "$partition_method" = "script" ]; then # create partitions from image profile script
    remove_existing_logical_volumes
    remove_existing_containers
    log " ** Creating Partition Table On $hard_drive From Custom Script ** " "display"
    $curlAuth --data "profileId=$profile_id" "${web}GetCustomPartitionScript" $curlEnd > /tmp/newPartLayout
    cat /tmp/newPartLayout >> $CLIENT_LOG
    bash /tmp/newPartLayout
  else #dynamic
    remove_existing_logical_volumes
    remove_existing_containers
    log " ** Creating Partition Table On $hard_drive ** " "display"
    log "imageProfileId=$profile_id&hdToGet=$image_hd_to_use&newHDSize=$hard_drive_size_bytes&clientHD=$hard_drive&taskType=deploy&partitionPrefix=$partition_prefix&lbs=$logical_block_size ${web}GetPartLayout"
    $curlAuth --data "imageProfileId=$profile_id&hdToGet=$image_hd_to_use&newHDSize=$hard_drive_size_bytes&clientHD=$hard_drive&taskType=deploy&partitionPrefix=$partition_prefix&lbs=$logical_block_size" "${web}GetPartLayout" $curlEnd > /tmp/newPartLayout
    if [ "$(cat /tmp/newPartLayout)" = "failed" ]; then
      error "Could Not Dynamically Create Partition Layout"
    fi
    
    log " ** Partition Creation Script ** "
    cat /tmp/newPartLayout >> $CLIENT_LOG
    bash /tmp/newPartLayout
    bash /tmp/createPartitions
  fi
  
  
  
}


function create_dynamic_cs_layouts
{
  #only runs for dynamic partition method
  local lv_created_count
  #Check if core storage was used in original image.  /tmp/corestorage created during par
  if [ ! -f "/tmp/corestorage" ]; then
    log "Core Storage Is Not Being Used"
    return 0
  fi
  
  cat /tmp/corestorage >>$CLIENT_LOG
  #The easy one, volume groups that were only on 1 disk and contained only 1 lv
  unique_vgs=$(cat /tmp/corestorage | cut -d: -f3 | uniq -u)
  for unique_vg in $unique_vgs; do
    vg_name=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f1)
    vg_pv=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f2)
    lv_name=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f4)
    lv_size_byte=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f5)
    lv_filesystem=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f6)
    
    diskutil cs create "$vg_name" "$vg_pv" 2>>$CLIENT_LOG
    new_vg_uuid=$(diskutil info $vg_pv | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
    
    fix_disk_identifiers
    
    #partitioning in OS X is just absolutely terrible.  Partitions don't get created to the size you set, because of that and some other things the lv won't fit in the vg based on CloneDeploy's calculations
    #try to create lv 10 times, each time subtracting 500 meg.
    lv_created_count=1
    while [ "$lv_created_count" -le "10" ]; do
      diskutil cs createVolume "$new_vg_uuid" "$lv_filesystem" "$lv_name" "${lv_size_byte}B" 2>>$CLIENT_LOG
      if [ "$?" != "0" ]; then
        lv_size_byte=$(( $lv_size_byte - 524288000 ))
        lv_created_count=$(( $lv_created_count + 1 ))
      else
        break;
      fi
    done
  done
  
  
  #The hard one, volume groups that either spanned multiple disks or contained more than 1 lv
  duplicate_vgs=$(cat /tmp/corestorage | cut -d: -f3 | uniq -d)
  for duplicate_vg in $duplicate_vgs; do
    log "duplicate vgs: $duplicate_vgs"
    duplicate_count=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f7 | uniq -d | wc -l)
    if [ "$duplicate_count" =  "0" ]; then
      #We are dealing with 1 volume group on 1 disk with multiple lvs
      single_lvs=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f7 | uniq -u)
      vg_name=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f1 | head -n1)
      vg_pv=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f2 | head -n1)
      diskutil cs create "$vg_name" "$vg_pv" 2>>$CLIENT_LOG
      new_vg_uuid=$(diskutil info $vg_pv | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
      fix_disk_identifiers
      for single_lv in $single_lvs; do
        lv_name=$(cat /tmp/corestorage | grep $duplicate_vg | grep $single_lv | cut -d: -f4)
        lv_size_byte=$(cat /tmp/corestorage | grep $duplicate_vg | grep $single_lv | cut -d: -f5)
        lv_filesystem=$(cat /tmp/corestorage | grep $duplicate_vg | grep $single_lv | cut -d: -f6)
        
        lv_created_count=1
        while [ "$lv_created_count" -le "10" ]; do
          diskutil cs createVolume "$new_vg_uuid" "$lv_filesystem" "$lv_name" "${lv_size_byte}B" 2>>$CLIENT_LOG
          if [ "$?" != "0" ]; then
            lv_size_byte=$(( $lv_size_byte - 524288000 ))
            lv_created_count=$(( $lv_created_count + 1 ))
          else
            break;
          fi
        done
        
      done
    else
      #We are dealing with 1 volume group spanned across multiple disks with 1 or more lvs
      spanned_lvs=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f7 | uniq -d)
      vg_name=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f1 | head -n1)
      log "spanned lvs: $spanned_lvs"
      log "vg name: $vg_name"
      for spanned_lv in $spanned_lvs; do
        first_vg_pv=$(cat /tmp/corestorage | grep $duplicate_vg | grep $spanned_lv | cut -d: -f2 | head -n1)
        log "diskutil cs create $vg_name $first_vg_pv"
        diskutil cs create "$vg_name" "$first_vg_pv" >> $CLIENT_LOG 2>&1
        fix_disk_identifiers
        new_vg_uuid=$(diskutil info $first_vg_pv | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
        remaining_vg_pvs=$(cat /tmp/corestorage | grep $duplicate_vg | grep $spanned_lv | cut -d: -f2 | grep -vw $first_vg_pv)
        for vg_pv in $remaining_vg_pvs; do
          log "diskutil cs addDisk $new_vg_uuid $vg_pv"
          diskutil cs addDisk "$new_vg_uuid" "$vg_pv" >> $CLIENT_LOG 2>&1
        done
      done
      #create lvs after all disks have been added to the vg
      for spanned_lv in $spanned_lvs; do
        first_vg_pv=$(cat /tmp/corestorage | grep $duplicate_vg | grep $spanned_lv | cut -d: -f2 | head -n1)
        new_vg_uuid=$(diskutil info $first_vg_pv | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
        lv_name=$(cat /tmp/corestorage | grep $duplicate_vg | grep $spanned_lv | cut -d: -f4)
        lv_filesystem=$(cat /tmp/corestorage | grep $duplicate_vg | grep $spanned_lv | cut -d: -f6 | head -n1)
        lv_sizes_byte=$(cat /tmp/corestorage | grep $duplicate_vg | grep $spanned_lv | cut -d: -f5)
        for lv_size_byte in $lv_sizes_byte; do
          if [ "$lv_size_byte" = "0" ]; then #the second drive will always have size of 0 because of calculations determined on server
            continue
          fi
          
          lv_created_count=1
          while [ "$lv_created_count" -le "10" ]; do
            diskutil cs createVolume "$new_vg_uuid" "$lv_filesystem" "$lv_name" "${lv_size_byte}B" >> $CLIENT_LOG 2>&1
            if [ "$?" != "0" ] && [ "$lv_size_byte" -ge 524288000 ]; then
              lv_size_byte=$(( $lv_size_byte - 524288000 ))
              lv_created_count=$(( $lv_created_count + 1 ))
            else
              break;
            fi
          done #end while
        done #end for lv_sizes_block
      done #end spanned_lvs
    fi
  done
}


function process_partitions()
{
  local partition_size_mb
  local array_index=-1
  
  
  if [ "$partition_method" = "standard_hfsp" ] || [ "$partition_method" = "standard_apfs" ]; then
    if [ "$(parse_json "$hd_schema" .Guid)" != "simple" ]; then
      error "A Standard Partition Layout Can Only Be Used With A Simple Upload Schema"
    fi
    #find and deploy only os and recovery
    get_partitions_according_to_mbr_gpt
    for partition in $mbr_gpt_partitions; do
      partition_prefix=$(echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g')
      break;
    done
    
    
    while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
      array_index=$(( $array_index + 1))
      clear_and_move_down
      current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
      log "$current_partition"
      
      if [ "$(parse_json "$current_partition" .Guid)" = "os" ]; then
        
        partition_size_bytes=5368709121
        if [ "$partition_method" = "standard_hfsp" ]; then
          download_image "$current_partition" $(echo "$(parse_json "$current_partition" .Type)" | sed 's/ //g') "${hard_drive}${partition_prefix}2"
        else
          download_image "$current_partition" Container-$(echo "$(parse_json "$current_partition" .Type)" | sed 's/ //g') "${hard_drive}${partition_prefix}2"
        fi
        
        
        elif [ "$(parse_json "$current_partition" .Guid)" = "recovery" ]; then
        partition_size_bytes=5368709121 #restoreexact doesn't seem to work with recovery
        download_image "$current_partition" $(echo "$(parse_json "$current_partition" .Type)" | sed 's/ //g') "${hard_drive}${partition_prefix}3"
        
      fi
    done
    
    elif [ "$partition_method" = "standard_cs" ]; then
    if [ "$(parse_json "$hd_schema" .Guid)" != "simple" ]; then
      error "A Standard Core Storage Partition Layout Can Only Be Used With A Simple Upload Schema"
    fi
    #find and deploy only os and recovery
    get_partitions_according_to_mbr_gpt
    for partition in $mbr_gpt_partitions; do
      partition_prefix=$(echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g')
      break;
    done
    
    
    while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
      array_index=$(( $array_index + 1))
      clear_and_move_down
      current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
      log "$current_partition"
      
      if [ "$(parse_json "$current_partition" .Guid)" = "os" ]; then
        for lv_disk in $(diskutil list | grep "(internal" | cut -d " " -f1); do
          #preventing deploying the same logical volume again.  If the volume group is spanned across multiple disks, it will be recognized multiple times
          if [[ "$imaged_lvs" == *"$lv_disk"* ]]; then
            continue
          fi
          
          log "processing lv disk $lv_disk"
          if diskutil info $lv_disk | grep "Logical Volume" > /dev/null; then
            partition_size_bytes=5368709121 #Don't care about the lv size at this point, but need a value for the download_image function
            download_image "$current_partition" $(echo "$(parse_json "$current_partition" .Type)" | sed 's/ //g') "$lv_disk"
            imaged_lvs="$imaged_lvs $lv_disk"
          fi
        done
        elif [ "$(parse_json "$current_partition" .Guid)" = "recovery" ]; then
        partition_size_bytes=5368709121 #restoreexact doesn't seem to work with recovery
        download_image "$current_partition" $(echo "$(parse_json "$current_partition" .Type)" | sed 's/ //g') "/dev/disk0${partition_prefix}3"
        
      fi
    done
  else #dynamic
    if [ "$(parse_json "$hd_schema" .Guid)" = "simple" ]; then
      error "Simple upload schemas do not support Dynamic Partitioning"
    fi
    while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
      array_index=$(( $array_index + 1))
      clear_and_move_down
      current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
      log "$current_partition"
      
      if [ -n "$(parse_json "$current_partition" .VolumeGroup)" ] && [ "$(parse_json "$current_partition" .VolumeGroup)" != "null" ]; then
        process_lvm
        continue
      fi
      
      if [ "$(parse_json "$current_partition" .Type)" = "EFI" ] || [ "$(parse_json "$current_partition" .Type)" = "efi" ]; then
        continue
      fi
      
      if [ "$(parse_json "$current_partition" .Type)" = "Boot OS X" ] || [ "$(parse_json "$current_partition" .Type)" = "boot os x" ]; then
        continue
      fi
      
      get_partitions_according_to_mbr_gpt
      partition_counter=0
      for partition in $mbr_gpt_partitions; do
        partition_counter=$(( $partition_counter + 1 ))
        partition_number=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
        if [ "$(parse_json "$current_partition" .Number)" = "$partition_number" ]; then
          partition_prefix=$(echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g')
          break;
        else
          partition_prefix=""
        fi
      done
      
      partition_size_bytes=$(diskutil info ${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number)  | grep "$partition_size_param" | cut -d "(" -f2 | cut -d " " -f1)
      download_image "$current_partition" part
      
    done
  fi
}


function process_lvm()
{
  local array_index=-1
  local volume_group="$(parse_json "$current_partition" .VolumeGroup.Name)"
  local make_swap_result
  local current_logical_volume
  local volume_group
  local lv_disk_vol_name
  local volume_group_uuid
  local volume_group_name
  
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$current_partition" .VolumeGroup.LogicalVolumeCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_logical_volume="$(parse_json "$current_partition" .VolumeGroup.LogicalVolumes[$array_index])"
    log "$current_logical_volume"
    lv_name="$(parse_json "$current_logical_volume" .Name)"
    
    #find the disk for the logical volume
    for lv_disk in $(diskutil list | grep "(internal" | cut -d " " -f1); do
      #preventing deploying the same logical volume again.  If the volume group is spanned across multiple disks, it will be recognized multiple times
      if [[ "$imaged_lvs" == *"$lv_disk"* ]]; then
        continue
      fi
      log "processing lv disk $lv_disk"
      if diskutil info $lv_disk | grep "Logical Volume" > /dev/null; then
        
        lv_disk_vol_name=$(diskutil cs info $lv_disk | grep "LV Name:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
        log "$lv_disk_vol_name and $lv_name"
        if [ "$lv_disk_vol_name" = "$lv_name" ]; then
          volume_group_uuid=$(diskutil info $lv_disk | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
          volume_group_name=$(diskutil cs list | grep "$volume_group_uuid" -A5 | grep Name: | cut -d : -f2 | sed -e 's/^[ \t]*//')
          log "$volume_group_uuid $volume_group_name"
          if [ "$volume_group_name" = "$volume_group" ]; then
            partition_size_bytes=5368709121 #Don't care about the lv size at this point, but need a value for the download_image function
            download_image "$current_logical_volume" "$volume_group-$lv_name" "$lv_disk"
            imaged_lvs="$imaged_lvs $lv_disk"
          fi
        fi
        
      fi
    done
    
    clear_and_move_down
  done
}


function download_image()
{
  local current_object="$1"
  local file_name_prefix="$2"
  local destination="$3"
  local asr_verb
  
  if [ -z "$destination" ]; then
    destination=${hard_drive}${partition_prefix}$(parse_json "$current_object" .Number)
    file_name_prefix=part"$(parse_json "$current_object" .Number)"
  fi
  
  log "partition size bytes: $partition_size_bytes"
  if [ "$partition_size_bytes" -le "5368709120" ]; then
    asr_verb="restoreexact"
  else
    asr_verb="restore"
  fi
  
  log " ** Starting Image Download For $destination ** " "display"
  
  $curlAuth --data "taskId=$task_id&partition=$destination" "${web}UpdateProgressPartition" $curlEnd
  
  sleep 7
  echo
  
  touch /tmp/osx.progress
  . mie_reporter & asr $asr_verb --source "$image_path/$file_name_prefix.dmg" --target $destination --erase --noprompt --noverify --puppetstrings 2>> $CLIENT_LOG | tee /tmp/osx.progress
  log ". mie_reporter &  asr $asr_verb --source $image_path/$file_name_prefix.dmg --target $destination --erase --noprompt --noverify --puppetstrings 2>> $CLIENT_LOG | tee /tmp/osx.progress"
  sleep 5
  
  killall mie_reporter &>/dev/null
  rm /tmp/osx.progress
}

function remove_existing_logical_volumes
{
  get_hard_drives "deploy"
  for hard_drive in $hard_drives; do
    if diskutil info $hard_drive | grep "Logical Volume" > /dev/null; then
      diskutil cs deleteVolume $hard_drive 2>> $CLIENT_LOG
    fi
  done
}

function remove_existing_containers
{
  containers=$(diskutil apfs list | grep "Container Reference:" | awk -F " " '{print $NF}')
  for container in $containers; do
    diskutil apfs deleteContainer $container 2>> $CLIENT_LOG
  done
}


function fix_disk_identifiers
{
  #This doesn't seem to work anymore from Sierra onward
  #If a core storage volume is created on the boot drive, osx will automatically create a new boot volume, when this happens the disk identifiers change and are in the wrong order
  #This is kind of a hack to get osx to rescan the drive and reorder the disk identifiers back to normal
  #This must done before any logical volumes are created or it doesn't work
  log "Fixing Disk Identifiers"
  get_hard_drives "deploy"
  current_hd_number=-1
  for hard_drive in $hard_drives; do
    drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    boot_volume=$(diskutil list $hard_drive | grep -i "boot os x" | awk -F "$drive_name" '{print $2}' )
    if [ -n "$boot_volume" ]; then
      log "$hard_drive needs identifiers updated.  Updating"
      partition_size_bytes=$(diskutil info "$drive_name$boot_volume" | grep "$partition_size_param" | cut -d "(" -f2 | cut -d " " -f1)
      partition_size_bytes=$(( $partition_size_bytes - 10485760 ))
      diskutil resizeVolume "$drive_name$boot_volume" ${partition_size_bytes}B 2>>$CLIENT_LOG
      log "$partition_size_bytes $drive_name $boot_volume"
    fi
  done
}

function get_partitions_according_to_mbr_gpt()
{
  mbr_gpt_partitions=""
  partitions_suffix=$(diskutil list | grep $drive_name | grep -vw $hard_drive | grep -vw $drive_name | grep -vi "volume on" | awk -F"$drive_name"  '{print $2}' )
  for suffix in $partitions_suffix; do
    mbr_gpt_partitions="$mbr_gpt_partitions $hard_drive$suffix"
  done
}

function change_computer_name()
{
  if [ -n "$computer_name" ] && [ "$change_computer_name" = "true" ]; then
    log "Setting Computer Name To $computer_name" "display"
    echo "scutil --set ComputerName $computer_name" > "/Volumes/$osx_target_volume/set_computer_name"
    echo "scutil --set HostName $computer_name" >> "/Volumes/$osx_target_volume/set_computer_name"
    echo "scutil --set LocalHostName $computer_name" >> "/Volumes/$osx_target_volume/set_computer_name"
    chroot "/Volumes/$osx_target_volume" bash set_computer_name
  fi
}

function install_munki()
{
  if [ "$install_munki" = "true" ]; then
    log "Installing Munki To $osx_target_volume" "display"
    installer -pkg /storage/resources/munkitools.pkg -target "/Volumes/$osx_target_volume" >> $CLIENT_LOG
    
    defaults write "/Volumes/$osx_target_volume/Library/Preferences/ManagedInstalls" SoftwareRepoURL "$munki_repo_url" >> $CLIENT_LOG
    if [ -n "$computer_name" ]; then
      defaults write "/Volumes/$osx_target_volume/Library/Preferences/ManagedInstalls" ClientIdentifier "$computer_name" >> $CLIENT_LOG
    fi
    
    if [ "$munki_requires_auth" = "true" ]; then
      munki_auth=$($curlAuth --data "profileId=$profile_id" "${web}GetMunkiBasicAuth" $curlEnd)
      defaults write "/Volumes/$osx_target_volume/private/var/root/Library/Preferences/ManagedInstalls" AdditionalHttpHeaders -array "Authorization: Basic $munki_auth" >> $CLIENT_LOG
    fi
    
  fi
}

function create_standard_hfsp()
{
  remove_existing_logical_volumes
  remove_existing_containers
  diskutil partitionDisk disk0 GPT JHFS+ "Macintosh HD" R JHFS+ "Recovery HD" 859.8M >> $CLIENT_LOG 2>&1
}

function create_standard_apfs()
{
  remove_existing_logical_volumes
  remove_existing_containers
  diskutil partitionDisk disk0 GPT JHFS+ "Macintosh HD" R >> $CLIENT_LOG 2>&1
  diskutil apfs createContainer disk0s2 >> $CLIENT_LOG 2>&1
}

function create_standard_cs()
{
  remove_existing_logical_volumes
  remove_existing_containers
  diskutil partitionDisk disk0 GPT JHFS+ "Macintosh HD" R JHFS+ "Recovery HD" 859.8M
  diskutil partitionDisk disk1 GPT JHFS+ "Macintosh HD" R
  
  diskutil cs create osVG /dev/disk0s2 /dev/disk1s2
  vg_uuid=$(diskutil info /dev/disk0s2 | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
  diskutil cs createVolume $vg_uuid JHFS+ "Macintosh HD" 100%
}

function fix_boot()
{
  echo
  log " ** Setting Startup Disk ** " "display"
  get_hard_drives "deploy"
  for hard_drive in $hard_drives; do
    get_partitions "false"
    if diskutil info "$hard_drive" | grep "Logical Volume" > /dev/null; then
      diskutil mount $hard_drive >> $CLIENT_LOG
	else
	   diskutil mountdisk $hard_drive >> $CLIENT_LOG
	fi  
  done
  
  ls -lh /Volumes >> $CLIENT_LOG
  systemsetup -setstartupdisk "$osx_target_volume" >> $CLIENT_LOG 2>&1
  
  if diskutil list | grep -i "apfs" | grep "$osx_target_volume" > /dev/null; then
    diskutil apfs updatePreboot "$osx_target_volume" >> $CLIENT_LOG 2>&1
  fi
  
  log " ...... Complete" "display"
  echo
}

function main()
{
  
  
  log " ** Checking Current Queue ** " "display"
  while true; do
    queue_status=$($curlAuth --data "taskId=$task_id" "${web}CheckQueue" $curlEnd)
    if [ "$(parse_json "$queue_status" .Result)" = "true" ]; then
      break
    else
      echo "** Queue Is Full, Waiting For Open Slot ** "
      echo " ...... Current Position $(parse_json "$queue_status" .Position)"
      sleep 5
    fi
  done
  log " ...... Complete" "display"
  echo
  
  sleep 2
  
  if [ -n "$pre_scripts" ]; then
    process_scripts "$pre_scripts"
  fi
  
  mount_smb
  
  process_hard_drives
  
  fix_boot
  
  change_computer_name
  
  install_munki
  
  if [ "$file_copy" = "True" ]; then
    log "file_copy_schema: profileId=$profile_id"
    file_copy_schema=$($curlAuth --data "profileId=$profile_id" "${web}GetFileCopySchema" $curlEnd)
    process_file_copy "$current_partition" "partition"
  fi
  
  if [ -n "$post_scripts" ]; then
    process_scripts "$post_scripts"
  fi
  
  checkout
}

main "$@"

